/*----------------------------------------------------------------------------*\ * File:        pc_cnffmt.hh * * Description: special CNF parser for CNF's produced by Marijn's proof checker. *              NOTE: When linking, option -lz *must* be used * * Author:      antonb\*----------------------------------------------------------------------------*/#pragma once#include <ctime>#include <cmath>#include <unistd.h>#include <signal.h>#include <zlib.h>#include <vector>#include "globals.hh"#include "id_manager.hh"#include "fmtutils.hh"#include "basic_clause.hh"#include "basic_clset.hh"#include "cl_id_manager.hh"using namespace std;//using namespace FMTUtils;//jpms:bc/*----------------------------------------------------------------------------*\ * DIMACS CNF Parser. (This borrows **extensively** from the MiniSAT parser)\*----------------------------------------------------------------------------*///jpms:ectemplate<class B>static void read_cnf_preamble(B& in, ULINT& nv, ULINT& ncls) {  ++in;  FMTUtils::skipTabSpace(in);  string fmt = FMTUtils::readString(in);  if (fmt != "cnf")    tool_abort("PARSE ERROR, expected \"cnf\" in preamble");  FMTUtils::skipTabSpace(in);  for (int cnt = 1; (*in != '\n' && *in != '\r'); ++cnt) {    LINT ival = FMTUtils::parseInt(in);    if (cnt == 1) { nv = ival; }    if (cnt == 2) { ncls = ival; }    FMTUtils::skipTabSpace(in);  }  ++in;}// A special version for the input clauses from the proof checker; the last// literal is assumed to be the selectortemplate<class B>static void read_cnf_clause(B& in, ULINT& mxid, ULINT first_sel, vector<LINT>& lits, LINT& slit) {  LINT parsed_lit;  lits.clear();  for (;;){    parsed_lit = FMTUtils::parseInt(in);    if (parsed_lit == 0) break;    ULINT var = abs(parsed_lit);    lits.push_back(parsed_lit);    if ((var < first_sel) && (var > mxid)) { mxid = var; }  }  slit = lits.back();  if (abs(slit) < first_sel) { tool_abort("parse error: selector variable is out of range"); }  lits.resize(lits.size() - 1);}using namespace std;/** Template parameters: B - input stream, CSet - the clause set to populate */template<class B, class CSet>static void parse_pccnf_file(B& in, IDManager& imgr, CSet& cldb) {  ULINT mnid = 1, mxid = 0, clid = 0;       // clause's index in the input file  ULINT nv = 0;  LINT ncls = 0;  vector<LINT> lits;  LINT slit = 0;  for (;;){    FMTUtils::skipWhitespace(in);    if (*in == EOF)      break;    else if (*in == 'c')      FMTUtils::skipLine(in);    else if (*in == 'p') {      read_cnf_preamble(in, nv, (ULINT&)ncls);      cldb.set_first_sel(nv + 1);      DBG(cout << "Read nv=" << nv << ", ncls=" << ncls << " from preamble" << endl;);    } else {      // depending on the current count of clauses, read with selector or into      // group 0      if (--ncls >= 0)         read_cnf_clause(in, mxid, nv, lits, slit);      else {        if (ncls == -1) { cldb.set_first_abbr(mxid+1); }        read_cnf_clause(in, mxid, lits);      }      ++clid;      // ANTON: for some applications its *essential* that clause id is the same      // as the index of the clause in the input; if the input file contains       // dublicate clauses the automatic id will not be incremented, which in       // turn will mess up indexes of all clauses that follow; so catch up      while (ClauseIdManager::Instance()->id() < clid)         ClauseIdManager::Instance()->new_id();      BasicClause* ncl = cldb.create_clause(lits); // fheras: Automatic clause ID      if (ncl != NULL) {        if (ncls >= 0) {          cldb.set_cl_grp_id(ncl, ncl->get_id());          ncl->set_slit(slit);        } else {          cldb.set_cl_grp_id(ncl, 0);        }      }      DBG(cout << "Created clause: "; ncl->dump();          cout << "slit = " << ncl->get_slit() << endl;);    }  }  imgr.new_ids(mxid, mnid, mxid);  // Register used IDs}/** Template parameters: CSet -- the clause set to populate */template<class CSet>class PCCNFParserTmpl {public:  inline void load_cnf_file(gzFile input_stream,			    IDManager& imgr, CSet& cldb) {    StreamBuffer in(input_stream);    parse_pccnf_file(in, imgr, cldb); }};// definition of CNFParser, for backward compatibilitytypedef PCCNFParserTmpl<BasicClauseSet> PCCNFParser;/*----------------------------------------------------------------------------*/